// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the Apache 2.0 License.

#include "kv/kv_types.h"
#include "node/byz_identity.h"

#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN
#include <doctest/doctest.h>

using namespace crypto;
using namespace ByzIdentity;

TEST_CASE("Polynomial evaluation example")
{
  // clang-format off
  std::vector<std::string> coefficients = {
    "7699140509354506296904379330388787711502937593685033925998668810583690207038429705926129602688681305405619847328173",
    "37918317783077992207075945298372013800209636724718746327158474975386339016607917448894651816099517951289611406292763",
    "3467828061652936489519861143038340128148454963564475447775042344042319260200137528770943678279745723710076733520812",
    "31550273572625802709384678740048388958405550483513682048313826168007327042521475275645189870165740186364950149570638",
    "307921627128950609390184175930712982756136233071715435787024235473522031567428100383716155375590382571736929796244",
    "17987233556361005764037359423216891628740372931380388256121900404198528245576272396610650932710031118771494292736282",
    "8022626363856810181081050720512516194870554147810831053444882051835195424353917408827605490318540556836533144678145",
    "1143739633003107074184532257423604655434275223885737188621261362924034487607223850341908606225434629784249592873081",
    "28336164975849996632750921038009054550241619710358810847675781408942232050965690324716480011465243344045015395410382",
    "23668433768395548708220181876672863765511850637728760044883254584889287121394895275659735818087588478357936296748282",
    "115432390781244234094084799873273367200321830214264663367137873187057456953982446441387228257870379944890950991721"
  };

  std::map<size_t, std::string> results = { 
    {1, "2609087456509984057527018402911992522702753398070658567359633100958894748334315484622573977064804402864380124175951"},
    {2, "600033377045403364484255920750414802244459225451071411994749650517908153806670023114586889834379072236082298405102"}, 
    {3, "29310319541045889029523499721117601466204953540776880280292465147266293137454599033004832179027471011459591309275866"},
    {4, "30674060811933428438134790257833741728590304563906502401877617868711566605534431951105817440783678234574689043234246"},
    {5, "8596054703407938703354146902602246416276384934442656761502061183677529431032978595080841109993426528870644015417057"},
    {6, "23284152075511080359120803822706382404499440777170148704478424906646283059390062259087100518775917350097560808899835"},
    {7, "38801938255697858165670253411933197362309834593259297093307448622358228394171235389239638597556755701376284889136796"},
    {8, "15739837012746047375101252353593659466642327816633496998490110153155566115087314435231835120086659333295286399322916"},
    {9, "5317115941907074178522217571281491910407863541621567170807164058784430949367798316640619535895400048871974226517152"}
  };
  // clang-format on

  Polynomial p(coefficients);
  for (const auto& [i, r] : results)
  {
    auto index = std::make_shared<BigNum>(i);
    auto expected = BigNum(r);
    auto evaluated = *p.eval(index);
    REQUIRE(evaluated == expected);
  }
}

TEST_CASE("eval_in_exp example")
{
  // clang-format off
  Polynomial x({"4662274122108106240021631361590296658730126368330097059057694451332620977124940553541538766554878574275001669017484", 
                "33675137677133611122865516303654450565993338292559167149019978517657614407894919893430320610995988435933624324640604", 
                "29938693961268115205839860967191776226677788049480965924904378120911331831629484753744027979147661882987167471837816", 
                "2814179160133403102122249792568787642812274134710020886404395107248539719778229217090686697482047301813888071918032", 
                "28706581893256681155333029483883573302643571770750349119682951144131078854169024628675431065019998414403591068704393", 
                "29013080213192948770630283317606899082750338821925638807650004883930881714162572847338691579067731625526949307141709", 
                "22277835779424603002613919326686976262180950474302526955819257779340759500944339529304205172014704263494460511780193", 
                "35440436385253054038384837465415412797918228455748500485696920730421415029767073209870222232037432008215167236071971", 
                "32626454062876124900292659304580646840391545751395301843192893654159795317431409074167024764187955718544963619697742", 
                "15951010556255911853262159331589934991983724496395207028513345882793323509657590398839601819876612646214299884062578", 
                "4002953525323384541588956777671823534581268689134507306918130036091859434380284294464962809268940152694276541514027"});
  Polynomial w({"29117916611984508997101164697719348480872803229200844293460579741596268798658425935628220465545115284255640760026118", 
                "22058296101719147339117603351741704236645571069056617541995942737680700096777754912356128353628874214631316252203598", 
                "21550564430006787468410098904226333903897534790440183736541830598160911637406692012720681466498301411701606054618274", 
                "30565451733807820301835127004864770457865502575603872460487358628503302038277266268189640732395715811686374347823031", 
                "924730760471921094888913951428273370497745348059205727495523761489746425388732529408804018716513758780010048460875", 
                "36760932824321461192033670019132778307440191446272218814222493425237240235761675390675873086453592479488619428600408", 
                "4870902973292053905752045330725667723058738673455228445994655206831609688539299207439989706543738485567986953402737", 
                "23220699946359513675911173542337673765644240927366459702333870847069458047584522798385944230378558087346345987644290", 
                "28531960007392007036008090557107942569764031460878473175417470145679155230511174651802411524226534155182096250282416", 
                "9007345059127260787676892169584046250406266049565591678448486511438928164434208454507959619464989542719377447849882", 
                "3433952102532624922890722998052513142964649357788507953803716788469362577587981131217762548959377364922610361795160"});
  
  // commitments = ['034c6cadc966d76c8a1a6fa3b70fd8503addf07f23d79fb840805f0c0611e34ba5f6f62c4fdb3b8353bf51f4163e1da5f8', '03b0945eeec3a1e250a99fb59f5a0b1f30193efdab9d2ca6df7f642ab5aa45d61ec658ea9f851defd2418660046f654643', '024c81c9dd534b80a5ac7bcecc7204b566091d6f38bc738d64151fe6e934644c1d41eaf5f2b36e6b9a59c9426957935704', '02a19b2783acd7ecce5e8ed6c053a6aca2b6114b58fe961f7bd32ebcf3eae176facbcecbd5d725f1659557d6a3b2f8e0d7', '03a8605cf4c27f564b0a530ad4585cb2a7dd316a4500f716385145ca50ef74d01a82db53839db888516ce0c17e9d9e87b1', '0255b5664b2221cdb8a4115b2028857f2481b43dbd22513a39bfbad00ff9fb4c0664e08e463ea9cc456e924125ba960959', '02a49cb9ff111dc39bc5eed7c01ec46eaf4ad77c2ada38aaa952bb51779bbe7ed57375c6222a0ec28b9d935a4380cc34ea', '029861efd56deb6caf6655fa0271466f747d4cde392e5a4f5e0f656b5d608e5bce7c08ea50bc623340966d3a3e0ab61ada', '031ced39d11925540151f955e6b2d809b196e968665679e1a0d72199563bad69d6c33fb7598b229f34faa1a0626e2bdaf5', '03f7593e8f807ea4360829249e7b2b15142cabbc2ee3aa217bb8d29c16834e870058578c94d024f2a85cf8731d367c2de6', '027665c9fe6ae2cc546de46233e5090344340cf1b6be93f9806b990fb02d644b2335b3f092f4af7be26e395ee57ee62405']
  // shares = [[2696600157859068659280862831578895076184719681939602559178518630253263902260286984072975646740181542776787782730691, 13032721569042710660230302026202983183658578575359970190467401994018385945361415445338634212049836028509815622993574], [10041607320769759504862105044869602058456425356332662407657800271293531914743051609109017536659829931860081903979619, 19369500392221663336753633356269839124285760235804733119807451626146660463923614094488361475233604393772698261542777], [24223160995480542699631893586293661769700923317826177818843766542618228449960228665042322099987850078549274062767253, 25120768880029158850936867537215438829860207202659343345434911432258664969411218367850273516514986237211368249419783], [19268540565756826705464094754659391088166512295297078515379569505394469785068251307383407111155246512521036222789526, 19190973542419727439841306980398068577742416656858619809089067979177926523756573367292487240533199043940415721657790], [19336863349361702598534807704223986373987441061033478558337154184994463093879238207034073424136082216975325542449009, 35947694765746295585067712726707242156550805308792496860950457042153774882763957097230943746559627891950704390894268], [35274057058796284843936317936217723711147403655269242282569900284919673831362075576856901097052997718540564647891438, 3904572361437739174534527985278188869183078603886889800685118194346067063820250757986689844739629167146692290809435], [11548156807780931044025692323714513281855896253546629256592976916862515515667149209451997210688081574972968323182479, 8888579280710936188880169531234072932968690891003442259967858001022407365614417926918004793213593890612311418049574], [2490631147175294205401265422044692804681413227007595207230280471291203253080530636798573990730046859778402460033609, 14938939728563743153195458932668666062131739268089460968346866697644267199504822644704175279948438358243994359702157], [33063125744509960120568315000026375519507463193501719116718832819880178015855368003558729061482176333307627842928752, 9738343396379810914115546951716800227930615915923419785195419352505891744665306338590333733882971562143191873741156]]  

  std::map<size_t, std::string> results = { 
    {1, "0210b10513b12d4dca91be44c2511c8b93d4a020809f90fa665bb416c8c5a2cb5efce9c400532c964def5b5cba41af4ece"},
    {2, "0298066cd8b52a4501d7800e2109217f8c9ed4b7524b75ee0000aaeaa0e216541155cdc32a023a13017d0f6a47680f95c2"},
    {3, "02983c5dfdf10bc2e133f7e0fead745f2e5e8219f1bbb9458091e1c13ba090367c0feb7d771e3c29569f64135b036da9e3"},
    {4, "027ea4a6562e09ff2ca4cc8afb550b7714036f0687b1f434d59f7849cb99d1e276129b4273a792c6392968ff0d6ea99d7f"},
    {5, "02d625728341b049d127089adad073cef8983e910de0931983d33cf430953ff25f852d31965fdaed059e3f1f89ebde39be"},
    {6, "038bad4b72a189197f7c3dcb9ed6a7484d0323d4391b838422b3a7cddfc32d9ff0492773721615b9d2abb9f3e17e578f01"},
    {7, "036df27b7c47e0eda424530a55745501a434d04ccab7d0055d74d323cc7a23a7f7a994c51d95592f59c361a28b54a5cc56"},
    {8, "022639a21d01200a7f92cdb06bcc626cbcdd333cd4c81f666a2134f4328577820820b9f50147b7c22259bee943c10e6954"},
    {9, "0339defc1991b06e5bb2eaeeaaffd138f02defb017c4011a854d13b1531ea5bb32e1bc54e336b966413a1097ece2c1e94c"},
  };
  // clang-format on

  auto go = EC::group_order();

  std::vector<EC::CompressedPoint> commitments;
  for (size_t j = 0; j < x.coefficients.size(); j++)
  {
    auto c = compress_x_wx(x.coefficients[j], w.coefficients[j]);
    commitments.push_back(c);
  }

  std::vector<std::vector<std::shared_ptr<BigNum>>> shares;
  for (size_t i = 0; i < 10; i++)
  {
    shares.resize(shares.size() + 1);
    auto index = std::make_shared<BigNum>(i + 1); // <---- +1 sharing index
    shares.back().push_back(x.eval(index));
    shares.back().push_back(w.eval(index));
  }

  for (size_t i = 1; i < 10; i++) // <---- +1 sharing index
  {
    auto eval_i = EC::eval_in_exp(commitments, i, go).compress();
    auto expected_i = compress_x_wx(shares[i - 1][0], shares[i - 1][1]);
    REQUIRE(eval_i == expected_i);
  }
}

TEST_CASE("eval_in_exp")
{
  size_t degree = 10;
  auto go = EC::group_order();

  auto x = Polynomial::sample_rss(degree);
  auto w = Polynomial::sample_rss(degree);

  std::vector<EC::CompressedPoint> commitments;
  for (size_t j = 0; j < degree + 1; j++)
  {
    auto c = compress_x_wx(x->coefficients[j], w->coefficients[j]);
    commitments.push_back(c);
  }

  std::vector<std::vector<std::shared_ptr<BigNum>>> shares;
  for (size_t i = 0; i < 10; i++)
  {
    shares.resize(shares.size() + 1);
    auto index = std::make_shared<BigNum>(i + 1); // <---- +1 sharing index
    shares.back().push_back(x->eval(index));
    shares.back().push_back(w->eval(index));
  }

  for (size_t i = 1; i < 10; i++) // <---- +1 sharing index
  {
    auto eval_i = EC::eval_in_exp(commitments, i, go).compress();
    auto expected_i = compress_x_wx(shares[i - 1][0], shares[i - 1][1]);
    REQUIRE(eval_i == expected_i);
  }
}

TEST_CASE("Debug signing deal")
{
  size_t t = 2;
  std::vector<size_t> indices = {2, 5, 7};
  SigningDeal deal(t, indices, false);

  // clang-format off
  deal.load({
    { "10014884927522895850327356177777625667978260337939389002110941575532553449296052180537322023555523813228576607014520",
      "16341302935712828055939570400053371625442944138326862601309546139321868278170469229016276949582840172941386133934238",
      "22733325687411215076796313729157744702163634859070151867248808792760888847980819625421343878626948678252216382474849",
      "0",
      "0"},
    { "11971040240021253050855990733199357635264196602076534095139749962191011218714097886800203842464169762930539838981047",
      "30266522339766330547875209837816374563136257208888330801420119685406168349405731716334307208652403104319846043578207",
      "12833249415650484131911965264874336946692530010710652062211180234551822035172024552641821338390106873090080256466796",
      "0",
      "0"},
    { "0",
      "13205794569199814472461093117211428820752412125765014907879295308183638919356155487359875604880043216475786674000347",
      "34685344325380327964522083139003084435536306270999210711520074143743902170655670161491578907007091186639185307431684",
      "37639340622829321449596249844298857577682454924769540346973809852196699371678357930162248040236232354807684319526556",
      "6644660354369846524921448351859610398683307692243094993327170051671951633341461233013940975251333834595136764613802"},
    { "0",
      "30134393016483678268202705920662787806702929734540798373077032206049520195946227699361337750381791453786194458434954",
      "12847305610441416543274060940241723347866315369337480715735914830432962510600885905904575194059939024246355508660685",
      "39230436614667971035442643960925254786422087350648162248200488457081460325107010130294392673080943010276921843742880",
      "13370229149470308411214868724733664915736295307991931318216659880585842740848512916194692080062648886982658994040987"},
    { "37224616507411555438010701434640303823301245501366136207464259578561594034994592609033007855712496695382479867095728",
      "19607885985106249555562436727104543113555475738870997075409383775047480625454757535395098560141892903494018293441562",
      "17932138509996119236010145888837752011369384395140876275723775364518873491524504241197898792017477605547227198389377",
      "32207904579103540016219868188033273552381026460328589666178735109463097167278377132610280560603020370937575938331145",
      "14575218702365232574685903037462414017020863264884773918261013636785026093261895872237206718006461150584426313012233"}
    });

  std::vector<std::vector<const char*>> expected_shares = {
    { "15424774959409974632554631594084506312279470239477381669884553186336867200220478432058382512772114131456913442954463",
      "5631063992972413037417151167898613133067613251299463942983994432327657860873868821839234688872518723267251990176716",
      "20954170342950347826617129772569229112926262023056461979607412920880476040639544818621718449567522581729906212563708",
      "8993068641290058176016065283135325066752716352040571999017705005813506502916069613427890012216546661624791143029192",
      "8603579245968905421444910945567389905995930153009588795633743176954693696607258550909051186557015684539915299298960"},
    { "29622442649055745653468409804690280468008024178880352002728407617121565653856671850769002806706723017369978375474647",
      "11310812973381258540682690342416288457301861668699129642156990897485491055684207451729797647651318149128572621230266",
      "19295343609495686105592049675131727719768551576501482877773334606413410181291178167141800839421048159780037702464121",
      "20154244250614175489382546333576839200368753110142924223733476981980446522034402902065907540682233606924050180129006",
      "7169114203779879449143499359297170193231816046324995217557936929873817757447325889658444049276036917053777646036949"},
    { "16874772072433375424273478602428689494625060016236022000115331727611743575038327777929465170634747937989439013599854",
      "25223787860975225891808915473740600058477442909342420726543408380892622006604888023211517412948035089940287978105997",
      "1384957605588707963627717129332315118212548008822339547498466018241422426027059844341847314502562477260297450126001",
      "22257379580037686129144416330342364539137835662438161680059452077356003923739768576714345163541869281354807539145059",
      "10168575713000123602259968848472340438785757710205718293243014176955755855823983470602512563918937778902648570761918"}
    };
  // clang-format on

  const auto& ss = deal.shares();
  REQUIRE(ss.size() == expected_shares.size());
  for (size_t i = 0; i < ss.size(); i++)
  {
    for (size_t j = 0; j < ss[i].size(); j++)
    {
      REQUIRE(*ss[i][j] == BigNum(expected_shares[i][j]));
    }
  }
}

TEST_CASE("Point compression example")
{
  // clang-format off
  auto x = std::make_shared<BigNum>("44743853537480180443520925379132040042002684141002748352811143751284261915166039290693308915657510350410983457679936");
  auto wx = std::make_shared<BigNum>("14683125135257787570162326319919597336533164736109972311473321227447104754776945196531521943653178855539464455193453");
  std::string result = "035a76d78d03d8efb5d356803ff18c4df30e79ce81f9f5d127a367c3dfa65c632ac9f75a60f0195b07282b9864a17a80bd";
  // clang-format on

  auto computed = ds::to_hex(compress_x_wx(x, wx));
  REQUIRE(computed == result);
}

TEST_CASE("Coefficient sum example")
{
  // clang-format off
  std::vector<SharePolynomials> sp = { 
    {             
      Polynomial({std::make_shared<BigNum>("5915022295699250484540554978180773988888296736599271417160786959649247307294099764185470405428602363247658116227438"), std::make_shared<BigNum>("29830293207082016981012389058417221261502225534799763539880716818983507516779862868134315836023930517210394645335567")}),
      Polynomial({std::make_shared<BigNum>("6641347515181446222822120506332362725077971803701127709120517968263585908094858075855642247067094778450235763135400"), std::make_shared<BigNum>("10366137176930826149881472566228629804995666946536158496205649181100006527574439571823822501712926260589215081486404")}) 
    },
    { 
      Polynomial({std::make_shared<BigNum>("12765128487249872987578856086560716832733736790696063183173521838900712311250556378645680572216399440053730177395610"), std::make_shared<BigNum>("16586850211669718366973542591259551202378486259002068521905326504916339718281336197199721300472727946525064979454866")}),
      Polynomial({std::make_shared<BigNum>("13937892153500515522265860880945360620435140277146765408239312989720441470566521807349416775367219902914189299022306"), std::make_shared<BigNum>("20657630538132061634237733051870863162488151076418947277342092056147758046347224647554545022786418204528179968984929")}) 
    }
  };

  std::vector<std::vector<std::shared_ptr<BigNum>>> expected = { 
    { std::make_shared<BigNum>("18680150782949123472119411064741490821622033527295334600334308798549959618544656142831150977645001803301388293623048"), std::make_shared<BigNum>("7015137222357256135706891549533158658800972523336385393839138044272187835947935495935080828344363550181025970847790") },
    { std::make_shared<BigNum>("20579239668681961745087981387277723345513112080847893117359830957984027378661379883205059022434314681364425062157706"), std::make_shared<BigNum>("31023767715062887784119205618099492967483818022955105773547741237247764573921664219378367524499344465117395050471333") },
  };
  // clang-format on

  auto go = EC::group_order();
  LOG_DEBUG_FMT("group order={}", go->to_string());

  auto sum = sum_share_polys(sp, go);
  REQUIRE(sum.size() == expected.size());
  for (size_t i = 0; i < sum.size(); i++)
  {
    REQUIRE(sum[i].size() == expected[i].size());
    for (size_t j = 0; j < sum[i].size(); j++)
    {
      REQUIRE(*sum[i][j] == *expected[i][j]);
    }
  }
}

TEST_CASE("Transfer share verification example")
{
  // clang-format off
  size_t j = 2, k = 1;
  auto x_jk = std::make_shared<BigNum>("3404745399376387349446961464068304116895309782550445238162763701247255203701755839194006564838437870466872039811625");
  auto wx_jk = std::make_shared<BigNum>("1182408208388050279587480277067963893298271305571199070749252435618088813722947198735605835372380041003730880430432");

  std::vector<std::vector<EC::CompressedPoint>> q_commits = { 
      { ds::from_hex("038d3dcaf7a137fee6a76117d8fc48b907502f0ec349baa5be0d327bf1aa5223f2c036d4740b0e803f6a403ba82f33248b"), ds::from_hex("031ad5bef2a548fda7c13e79e259e8e3e0227358557ddcc05e5f78847237cdb1d73f48e7095e0ee5f4641b653347b50fdc") },
      { ds::from_hex("02bd86407b1d5af797a08e9eefbf3e0d2527844a256e3da73e5cafb7b9827ee6c266ca9ba2cdbd2947be24ebb5d1c279cc"), ds::from_hex("023e60f748d0e502f92e6f48d88246968676e772bccf3276ede5849fabc0023a8d38182ebc0fc8fc0791ed064e6246f6f5")}
  };
  
  std::vector<EC::CompressedPoint> qj_commits = { ds::from_hex("03373dda8f03ff0970136bbbc0d991c7f98154541cb0c92c4bf433254566fa43b97b4e9e7f32cb6e4fd9b8e2d0c944be73"), ds::from_hex("032c989877e9ab0d861bbbbf9cce7566be451d2fdcbc87753a5fc85e5c7e0c68fe336407b198bc1d595903fd255984bc13") };


  EC::CompressedPoint expected = ds::from_hex("03bdc297bd2191eca8da2db5f2669634d4b98bb6e049ca800c3f67ef37301fb5f1af44d3c56dd611c7208e5e94e8cd9009");
  // clang-format on

  size_t t = 1;
  std::vector<ccf::NodeId> nids;
  for (size_t i = 0; i < 3 * t + 1; i++)
  {
    nids.push_back(ccf::NodeId(std::to_string(i)));
  }
  SamplingSession s(0, t, nids, false);

  std::vector<EC::CompressedPoint> x_commits = {ds::from_hex("00")};
  REQUIRE_NOTHROW(s.verify_transfer_shares(
    q_commits, x_commits, nids[k - 1], nids[j - 1], x_jk, wx_jk));
}

TEST_CASE("Transfer share verification example 2")
{
  // clang-format off
  size_t j = 3, k = 2;
  auto x_jk = std::make_shared<BigNum>("12062364093736520888717105107218074030973304316729793466779616817057436355915221370697778439765679835758839732852148");
  auto wx_jk = std::make_shared<BigNum>("27906723981776944258487792706296304860283159050826708389424578642098345842214816843589571192377365370104711161526696");

  std::vector<std::vector<EC::CompressedPoint>> q_commits = { 
      { ds::from_hex("034795a0fe55dfaa79f4bb53149b3e57157e6bc8c41f4a010fbb0940925cb8678fa1081fa1d9058f476d95c50e658501aa"), ds::from_hex("03ccc418f7bccb4fa1ea47799625e4cfc9b9df3207417a7f1b3f90d3c5b860ac25ec3aa53c29b74580c46d22a768f099dc") },
      { ds::from_hex("02b1ae3953ade8258913e4b99bac7a5355a1eb45ccd3b6357562023fbf90673d22c27b8e0ce5feb7a12831d0bca919587f"), ds::from_hex("02c518ea16cd46fb87397f0ed9a5fdafb5b6d001ba7d531b67db0c00ba21dee268b81b87d5f9dbece773f3cd2dd6971adc")}
  };
  
  std::vector<EC::CompressedPoint> qj_commits = { ds::from_hex("02b2e32137cc64ae2be3ba2f82ead3eaab22dce3c8ed58185ddf5ae06a53fe87b0e2d1f3b9f67f4c6d6a60b6141217c07a"), ds::from_hex("039f464ec777e391231f7d54f5490c9b2f62b49a9e3946a870a462aa7b6190fc5974f07eaf1384272b1958457c47cbe057") };

  EC::CompressedPoint expected = ds::from_hex("0255e5727fdb0a44bb855977a4ecec6ab835ca098efe28e982ffde837e4656b5392c1b5288255937ef3411a67d4a0236a3");
  // clang-format on

  size_t t = 1;
  std::vector<ccf::NodeId> nids;
  for (size_t i = 0; i < 3 * t + 1; i++)
  {
    nids.push_back(ccf::NodeId(std::to_string(i)));
  }
  SamplingSession s(0, t, nids, false);

  std::vector<EC::CompressedPoint> x_commits = {ds::from_hex("00")};
  REQUIRE_NOTHROW(s.verify_transfer_shares(
    q_commits, x_commits, nids[k - 1], nids[j - 1], x_jk, wx_jk));
}

TEST_CASE("Compute signature")
{
  const char* message_to_sign = "Hello";
  size_t t = 1;

  auto group_order = EC::group_order();
  auto x = BigNum::Random(*group_order);

  // bypassing Byzantine sampling of the private signing key.
  auto xp = Polynomial::sample_zss(t, x);
  // auto x_commits = [ (commit.basis[0] * xp.coefficients[u]).compress() for
  // u in range(t+1) ];

  // sharing_indices = [ j + 1 for j in range(2*t+1) ]

  // # (1) DEALING: deals is a list of (shares, commits, proof) triples
  // # we skip the elaboration/encryption of DEAL messages to carry it
  // # and their allocation to a signining session
  // deals = [ SigningDeal.deal(t, sharing_indices, defensive=defensive) for i
  // in range(t+1)] commits = None if defensive:
  //     # normally re-computed by every replica
  //     dealer_commits = [ deals[i][1] for i in range(t+1) ]
  //     commits = [ batch_commit(dealer_commits,u) for u in range(2*t+1) ]

  // # (2) After accepting the deals, every replica aggregates their shares
  // # and sends their OpenK message.
  // def core_session(j):
  //     session = SignSession()
  //     session.defensive = defensive
  //     session.shares = sum_shares([ deals[i][0][j] for i in range(t+1) ])
  //     session.batched_commits = commits
  //     if defensive:
  //         verify_shares_signing(j+1,session.shares,commits)
  //     return session
  // session = [ core_session(j) for j in range(2*t+1) ]
  // openKs = [ compute_OpenK(session[j]) for j in range(2*t+1) ]

  // K_shares = [ openKs[j][0] for j in range(2*t+1)]
  // if defensive:
  //     # normally verified by every replica
  //     # note the defensive protocol only need t+1 verified messages
  //     for j in range(2*t+1):
  //         Cx = K_shares[j]
  //         Cj = compute_C_at_j(commits,j+1)
  //         proof = openKs[j][1]
  //         assert zkp.verify_OpenK((Cx,Cj), proof)

  // # (3) After receiving the OpenKs, every replica computes r, then their
  // shares of the signature # Only this last "online" step of signing depends
  // on the message and shared private key

  // K = interpolate_and_check(K_shares, sharing_indices, t)
  // r = int((Point.decompress(K).x) % order)
  // for j in range(2*t+1):
  //     session[j].txt = txt
  //     session[j].r = r
  // # sig_shares is a list of (ak_share, s_share, proof)
  // sig_shares = [ compute_signature_shares_core(session[j], xp.eval(j+1), 0)
  // for j in range(2*t+1) ]

  // # (4) Anyone can then aggregate the shares and interpolate the signature
  // ak_shares = [ sig_shares[j][0] for j in range(2*t+1)]
  // s_shares = [ sig_shares[j][1] for j in range(2*t+1)]

  // if defensive:
  //     for j in range(2*t+1):
  //         m = int(crypto_provider.hash_msg(session[j].txt))
  //         Cy_pv = compress(
  //             Point.decompress(compute_C_at_j(x_commits, j+1)) +
  //             Point.decompress(compute_C_at_j(session[j].batched_commits,
  //             j+1)))
  //         proof = sig_shares[j][2]
  //         assert zkp.verify_mult(Cy_pv,m,session[j].r,ak_shares[j],
  //         s_shares[j], proof)
  // # these 5 lines should be factored out of keying
  // ak = lagrange_interpolate(ak_shares, sharing_indices, 0)
  // s1 = lagrange_interpolate(s_shares, sharing_indices, 0)
  // s = (s1 * inv(ak)) % order
  // signature = encode_dss_signature(session[0].r, s)

  // # check signing succeeded using another, plain ECDSA implementation
  // # (the call to verify may fail with an InvalidSignature exception)
  // # crypto_provider.ecdsa_verify(X, signature, message_to_sign)
  // // VK verification key is the public part of `x`
  // VK.verify(signature, bytes(txt, "utf-8"), ec.ECDSA(hashes.SHA256()))
}

std::map<ccf::NodeId, std::map<ccf::NodeId, std::shared_ptr<crypto::KeyAesGcm>>>

make_node_keys(const std::vector<ccf::NodeId>& nids)
{
  EntropyPtr entropy = create_entropy();
  std::
    map<ccf::NodeId, std::map<ccf::NodeId, std::shared_ptr<crypto::KeyAesGcm>>>
      r;
  for (auto nid_from : nids)
  {
    for (auto nid_to : nids)
    {
      if (nid_from != nid_to)
      {
        r[nid_from][nid_to] = crypto::make_key_aes_gcm(entropy->random(32));
      }
    }
  }
  return r;
}

TEST_CASE("Establish Byzantine identity")
{
  size_t t = 1;

  std::vector<ccf::NodeId> nids;
  for (size_t i = 0; i < 3 * t + 1; i++)
  {
    nids.push_back(ccf::NodeId(std::to_string(i)));
  }

  SamplingSession s(0, t, nids, false);

  auto keys = make_node_keys(nids);

  for (size_t i = 0; i < 3 * t + 1; i++)
  {
    s.nodes.push_back({nids[i], keys});
    for (size_t j = 0; j < t; j++)
    {
      s.nodes[i].x_commits.push_back({0});
    }
  }

  // Prepare t+1 deals
  for (size_t i = 0; i < t + 1; i++)
  {
    LOG_TRACE_FMT("Sample #{} begin", i);
    s.nodes[i].deal = std::make_shared<SamplingDeal>(s.sharing_indices);
    LOG_TRACE_FMT("Sample #{} end", i);
  }

  // Dealers encrypt shares for each other node
  for (size_t i = 0; i < t + 1; i++)
  {
    s.nodes[i].encrypt_shares(nids, s.all_encrypted_shares);
  }

  // Nodes decrypt all shares
  for (auto& n : s.nodes)
  {
    n.decrypt_shares(nids, s.all_encrypted_shares);
  }

  for (auto& from : s.nodes)
  {
    if (from.deal)
    {
      auto plain = from.deal->serialise();

      for (auto& to : s.nodes)
      {
        if (from.nid != to.nid)
        {
          REQUIRE(plain == to.decrypted_shares[from.nid]);
        }
      }
    }
  }

  // All nodes validate the shares (sum_shares_reshare) and reply with
  // "reshares" for each node (evaluations of the sharing/witness polynomials at
  // each sharing index; this includes all 3*t+1 nodes). All reshares are also
  // encrypted by the node-to-node keys.

  for (auto& node : s.nodes)
  {
    node.batch_commits(s);

    // Sum shares and verify them.
    auto sum = node.sum_polynomials(s);
    try
    {
      // sum received, batched commits received
      REQUIRE_NOTHROW(node.verify_shares(s, sum));
    }
    catch (std::exception& ex)
    {
      // --> Blame
    }

    s.resharings[node.nid] = node.compute_resharing(s, sum);
    // encryption of resharings NYI
  }

  for (auto& node : s.nodes)
  {
    for (auto& id : nids)
    {
      auto srid = s.resharings[id];
      node.add_reshare(s, id, srid);

      if (node.reshares.size() >= 2 * t + 1)
      {
        node.compute_x_wx_shares(s);
        // send OpenKey
        break;
      }
    }
  }

  // All nodes have key shares
  for (auto& node : s.nodes)
  {
    LOG_TRACE_FMT("{}", node.nid);
    auto zero = *BigNum::Zero();
    REQUIRE(*node.x != zero);
    REQUIRE(*node.x_witness != zero);
  }
}
